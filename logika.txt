Squawk – specyfikacja mechaniki gry 
1. Typ gry

Gatunek: Multiplayer arcade, top-down / 2D continuous movement

Inspiracja: slither.io

Jednostka sterowana: Papuga (segmentowana, rosnąca struktura)

Stan gry: gra trwa do momentu kolizji jednostki gracza

2. Encje
2.1 Encja: Parrot (Player / Bot)

Atrybuty:

position (x, y)

direction (kąt / wektor normalizowany)

speed_base (stała)

speed_boost (stała > speed_base)

energy (liczba zmiennoprzecinkowa)

size (funkcja energy)

segments[] (lista segmentów ciała / piór)

vision_radius (zależny od size)

isBoosting (bool)

isAlive (bool)

Zależności:

size = f(energy)

turn_rate = g(size) (im większy size, tym mniejsza zwrotność)

3. Ruch
3.1 Aktualizacja pozycji (tick gry)
position += direction * current_speed * deltaTime
3.2 Skręt

direction interpolowany w stronę kursora / celu AI

maksymalny kąt skrętu ograniczony przez turn_rate

3.3 Przyspieszenie
if isBoosting and energy > min_energy:
current_speed = speed_boost
energy -= boost_cost * deltaTime
spawn FeatherParticle behind tail
else:
current_speed = speed_base
4. Energia (masa)
4.1 Typy energii

Encja: FeatherEnergy

value (float)

position

Typy:

WORLD_FEATHER (spawn losowy)

BOOST_FEATHER (spawn przy boost)

DEATH_FEATHER (spawn po śmierci)

4.2 Zbieranie energii
if Parrot.collider intersects FeatherEnergy.collider:
Parrot.energy += FeatherEnergy.value
destroy FeatherEnergy
5. Kolizje
5.1 Warunek śmierci

Papuga ginie jeśli:
Parrot.head collider intersects:
- body collider innej papugi
- boundary collider mapy
5.2 Warunki bezpieczne

Kolizja body–body: brak efektu

Kolizja z własnym ciałem: brak efektu

5.3 Śmierć
isAlive = false
spawn DeathFeathers along segments
remove Parrot entity
6. Wzrost i segmentacja

Każdy przyrost energii może:

zwiększyć długość ogona

zwiększyć rozmiar segmentów

Segmenty:

poruszają się ruchem opóźnionym (follow leader)

zachowują stały dystans

7. Mapa

Typ: ograniczona plansza 2D

Granice: niewidzialne, kolizja = śmierć

Elementy wizualne: chmury, wyspy (bez kolizji)

8. Kamera

Kamera śledzi głowę papugi

Zoom = h(size)

9. Ranking

Ranking sortowany malejąco po energy / size

Brak punktów za eliminacje

10. Boty (AI)
10.1 Encja: BotParrot

Dziedziczy po Parrot

Dodatkowe atrybuty:

state (ENUM)

target (Entity / position)

10.2 Stany AI

ENUM BotState:

WANDER

FEED

ATTACK

EVADE

TRAPPED

10.3 Logika decyzyjna (tick AI)
scan nearby entities within vision_radius


if imminent collision:
state = EVADE
elif enemy smaller and close:
state = ATTACK
elif energy source nearby:
state = FEED
else:
state = WANDER
10.4 Zachowanie w stanach

WANDER

losowy kierunek

brak boosta

FEED

kierunek w stronę FeatherEnergy

niski boost

ATTACK

przecinanie trajektorii celu

krótkie boosty

EVADE

gwałtowny skręt

boost w przeciwną stronę

TRAPPED

ciasne okręgi

wysokie ryzyko śmierci

Boty:

nie przewidują przyszłych ruchów

reagują lokalnie

11. Balans

Małe jednostki: wysoka zwrotność

Duże jednostki: kontrola przestrzeni

Boost = ryzyko

12. Założenia projektowe

Brak power-upów

Brak różnic statystycznych skinów

Jednolita fizyka dla graczy i botów