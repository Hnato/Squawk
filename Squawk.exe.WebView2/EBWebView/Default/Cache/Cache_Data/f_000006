const config = {
    type: Phaser.AUTO,
    parent: 'game-container',
    width: window.innerWidth,
    height: window.innerHeight,
    backgroundColor: '#000000',
    scene: {
        preload: preload,
        create: create,
        update: update
    }
};

const COLORS = [
    { 
        name: 'Green',
        base: 0x5CCB00, 
        accent: 0xA8E600, 
        beak: 0xFFD400, 
        wing: 0xFFEA00,
        outline: 0x2D6600
    },
    { 
        name: 'Blue',
        base: 0x2CB7FF, 
        accent: 0x7DD8FF, 
        beak: 0xFF9E00, 
        wing: 0x005EFF,
        outline: 0x165C80
    },
    { 
        name: 'Purple',
        base: 0x8A2BE2, 
        accent: 0xB266FF, 
        beak: 0xFFB347, 
        wing: 0x4B0082,
        outline: 0x451571
    }
];

let game = new Phaser.Game(config);
let socket;
let playerId;
let players = {};
let feathers = {};
let cursors;
let isBoosting = false;
let mapRadius = 7500;
let cam;

function preload() {
    this.load.image('parrot_head', 'logo.png');
}

function create() {
    console.log('Phaser create() started');
    cam = this.cameras.main;
    cursors = this.input.keyboard.createCursorKeys();
    
    const bg = this.add.graphics();
    bg.setDepth(-10);
    bg.fillStyle(0x050505, 1);
    bg.fillCircle(mapRadius, mapRadius, mapRadius);
    
    const grid = this.add.grid(mapRadius, mapRadius, mapRadius * 2, mapRadius * 2, 200, 200, 0x000000, 0, 0xffffff, 0.03);
    grid.setDepth(-9);
    
    const border = this.add.graphics();
    border.setDepth(-8);
    border.lineStyle(10, 0xffffff, 0.1);
    border.strokeCircle(mapRadius, mapRadius, mapRadius);

    this.mapGraphics = { bg, grid, border };

    cam.centerOn(mapRadius, mapRadius);

    const miniMapSize = 200; 
    const miniMapMargin = 20;
    this.miniMapContainer = this.add.container(miniMapMargin, this.scale.height - miniMapSize - miniMapMargin);
    this.miniMapContainer.setScrollFactor(0);
    this.miniMapContainer.setDepth(1001);
    this.miniMapContainer.setVisible(false);

    const miniMapBg = this.add.graphics();
    miniMapBg.fillStyle(0x000000, 0.7);
    miniMapBg.fillCircle(miniMapSize/2, miniMapSize/2, miniMapSize/2);
    miniMapBg.lineStyle(2, 0xffffff, 0.3);
    miniMapBg.strokeCircle(miniMapSize/2, miniMapSize/2, miniMapSize/2);
    this.miniMapContainer.add(miniMapBg);

    this.miniMapSnakes = this.add.graphics();
    this.miniMapContainer.add(this.miniMapSnakes);

    this.miniMapPlayer = this.add.graphics();
    this.miniMapContainer.add(this.miniMapPlayer);

    const maskShape = this.make.graphics();
    maskShape.fillStyle(0xffffff);
    maskShape.fillCircle(miniMapSize/2, miniMapSize/2, miniMapSize/2);
    const mask = maskShape.createGeometryMask();
    this.miniMapSnakes.setMask(mask);

    this.miniMapDebug = this.add.text(miniMapSize/2, miniMapSize + 10, '', { fontSize: '10px', fill: '#ffffff' }).setOrigin(0.5);
    this.miniMapContainer.add(this.miniMapDebug);
    console.log('MiniMap system initialized at:', miniMapMargin, this.scale.height - miniMapSize - miniMapMargin);

    window.onerror = function(message, source, lineno, colno, error) {
        console.error('GLOBAL JS ERROR:', message, 'at', source, ':', lineno, ':', colno);
        return false;
    };

    document.getElementById('startBtn').addEventListener('click', () => {
        const name = document.getElementById('playerName').value || 'Papuga';
        connectToServer(name);
        document.getElementById('login').style.display = 'none';
        document.getElementById('leaderboard').style.display = 'block';
        const scene = game.scene.scenes[0];
        if (scene && scene.miniMapContainer) {
            scene.miniMapContainer.setVisible(true);
        }
});
}

function connectToServer(name) {
    console.log('Attempting to connect to server at ws://localhost:5004...');
    socket = new WebSocket('ws://localhost:5004');

    socket.onopen = () => {
        console.log('Połączono z serwerem, wysyłanie prośby o dołączenie...');
        socket.send(JSON.stringify({ Type: 'join', Name: name }));
    };

    socket.onmessage = (event) => {
        try {
            const data = JSON.parse(event.data);

            if (data.Type === 'welcome') {
                playerId = data.PlayerId;
                console.log('Welcome received, playerId:', playerId);
                if (data.MapRadius) {
                    mapRadius = data.MapRadius;
                    console.log('Map radius updated to:', mapRadius);
                    const scene = game.scene.scenes[0];
                    if (scene && scene.mapGraphics) {
                        const { bg, grid, border } = scene.mapGraphics;
                        bg.clear();
                        bg.fillStyle(0x050505, 1);
                        bg.fillCircle(mapRadius, mapRadius, mapRadius);
                        
                        grid.setPosition(mapRadius, mapRadius);
                        grid.setSize(mapRadius * 2, mapRadius * 2);
                        
                        border.clear();
                        border.lineStyle(10, 0xffffff, 0.1);
                        border.strokeCircle(mapRadius, mapRadius, mapRadius);

                        scene.cameras.main.centerOn(mapRadius, mapRadius);
                    }
                }
            } else if (data.Type === 'update') {
                handleGameUpdate(data);
            } else if (data.Type === 'death') {
                playerId = null;
                if (socket) {
                    socket.close();
                }
                document.getElementById('login').style.display = 'block';
                document.getElementById('leaderboard').style.display = 'none';
                const scene = game.scene.scenes[0];
                if (scene && scene.miniMapContainer) {
                    scene.miniMapContainer.setVisible(false);
                }
            } else if (data.Type === 'leaderboard') {
                updateLeaderboard(data.Entries);
            }
        } catch (err) {
            console.error('Error parsing socket message:', err, event.data);
        }
    };

    socket.onclose = () => {
        console.log('Rozłączono z serwerem');
        document.getElementById('login').style.display = 'block';
    };
}

function handleGameUpdate(data) {
        const scene = game.scene.scenes[0];
        if (!scene) return;

        if (!data || !data.Parrots || !data.Feathers) {
            console.warn('Incomplete data received from server');
            return;
        }

    const currentIds = data.Parrots.map(p => p.Id);
    if (data.Parrots) {
        Object.keys(players).forEach(id => {
            if (!data.Parrots.find(p => p && p.Id === id)) {
                if (players[id]) {
                    if (players[id].segments) {
                        players[id].segments.forEach(s => s && s.destroy());
                    }
                    if (players[id].nameText) {
                        players[id].nameText.destroy();
                    }
                    delete players[id];
                }
            }
        });
    }

    if (data.Parrots) {
        data.Parrots.forEach(pData => {
            if (!pData || !pData.Id) return;
            
            if (!players[pData.Id]) {
            let colorIndex = pData.Name.length % COLORS.length;
            if (pData.Id === playerId) colorIndex = 0; 
            
            players[pData.Id] = {
                segments: [],
                nameText: scene.add.text(0, 0, pData.Name, { 
                    fontSize: '14px', 
                    fill: '#ffffff',
                    fontStyle: '600',
                    stroke: '#000000',
                    strokeThickness: 2,
                    padding: { x: 4, y: 2 }
                }).setOrigin(0.5),
                color: COLORS[colorIndex],
                lastEnergy: pData.Energy,
                lastSize: pData.Size || 1,
                currentVisualSize: pData.Size || 1,
                wingRotation: 0
            };
            players[pData.Id].nameText.setAlpha(0);
            scene.tweens.add({
                targets: players[pData.Id].nameText,
                alpha: 0.8,
                duration: 500
            });
        }

        const p = players[pData.Id];
        
        if (p.currentVisualSize !== pData.Size) {
            scene.tweens.add({
                targets: p,
                currentVisualSize: pData.Size,
                duration: 800,
                ease: 'Cubic.out'
            });
        }
        
        const size = p.currentVisualSize || 1;
        const headHeight = 24 * size;
        
        if (!pData.Segments || pData.Segments.length === 0) return;

        const distToPlayer = Phaser.Math.Distance.Between(cam.worldView ? cam.worldView.centerX : 0, cam.worldView ? cam.worldView.centerY : 0, pData.X, pData.Y);
        const isFar = distToPlayer > 1500;
        const maxSegmentsLOD = isFar ? Math.min(pData.Segments.length, 5) : pData.Segments.length;

        while (p.segments.length < maxSegmentsLOD) {
            const isHead = p.segments.length === 0;
            const segmentIndex = p.segments.length;
            const isTail = segmentIndex >= pData.Segments.length - 3 && pData.Segments.length > 5;
            
            let seg;
            if (isHead) {
                seg = scene.add.container(0, 0);
                
                const headBase = scene.add.ellipse(0, 0, headHeight, headHeight * 1.1, p.color.base);
                headBase.setStrokeStyle(headHeight * 0.1, p.color.outline);
                
                const eyeWhite = scene.add.circle(headHeight * 0.2, -headHeight * 0.1, headHeight * 0.35 / 2, 0xffffff);
                const pupil = scene.add.circle(headHeight * 0.25, -headHeight * 0.1, headHeight * 0.2 / 2, 0x000000);
                
                const beakUpper = scene.add.ellipse(headHeight * 0.5, headHeight * 0.1, headHeight * 0.6, headHeight * 0.4, p.color.beak);
                beakUpper.setStrokeStyle(2, p.color.outline);

                seg.add([headBase, beakUpper, eyeWhite, pupil]);
                seg.headFeatures = { headBase, beakUpper, eyeWhite, pupil };
            } else {
                seg = scene.add.container(0, 0);
                const segWidth = headHeight * 0.8;
                const segHeight = headHeight * 0.6;
                
                const bodyPart = scene.add.rectangle(0, 0, segWidth, segHeight, p.color.base, 1);
                bodyPart.setStrokeStyle(segHeight * 0.1, p.color.outline);
                
                seg.add([bodyPart]);

                if (isTail && !isFar) {
                    const wing = scene.add.ellipse(0, 0, headHeight * 1.2, headHeight * 0.4, p.color.wing);
                    wing.setStrokeStyle(2, p.color.outline);
                    wing.setOrigin(0, 0.5);
                    seg.add(wing);
                    seg.wing = wing;
                    seg.sendToBack(wing);
                }
            }
            
            p.segments.push(seg);
        }

        while (p.segments.length > maxSegmentsLOD) {
            const seg = p.segments.pop();
            seg.destroy();
        }

        const isVisible = true;
        
        if (isVisible) {
            p.nameText.setVisible(true);
            p.segments.forEach(s => s.setVisible(true));
            
            p.wingRotation = Math.sin(Date.now() / 200) * 0.2;

            pData.Segments.forEach((pos, i) => {
                if (i >= p.segments.length) return;
                const seg = p.segments[i];
                seg.x = pos.X;
                seg.y = pos.Y;
                
                const angle = i < pData.Segments.length - 1 ? 
                    Math.atan2(pData.Segments[i].Y - pData.Segments[i+1].Y, pData.Segments[i].X - pData.Segments[i+1].X) : 
                    (i > 0 ? Math.atan2(pData.Segments[i-1].Y - pData.Segments[i].Y, pData.Segments[i-1].X - pData.Segments[i].X) : 0);
                
                seg.rotation = angle;
                
                const boostScale = pData.IsBoosting ? 1.15 : 1.0;
                seg.setScale((size / (1 + (pData.Energy/100))) * boostScale);

                if (seg.headFeatures) {
                    if (pData.IsBoosting) {
                        seg.headFeatures.headBase.setStrokeStyle(headHeight * 0.15, 0xffffff, 0.8);
                        
                        if (i === 0 && Math.random() < 0.3) {
                            const trail = scene.add.particles(0, 0, 'parrot_head', {
                                x: seg.x,
                                y: seg.y,
                                speed: 20,
                                scale: { start: 0.1 * size, end: 0 },
                                alpha: { start: 0.4, end: 0 },
                                lifespan: 300,
                                tint: p.color.base,
                                maxParticles: 1
                            });
                            scene.time.delayedCall(300, () => trail.destroy());
                        }
                    } else {
                        seg.headFeatures.headBase.setStrokeStyle(headHeight * 0.1, p.color.outline);
                    }
                }

                if (seg.wing) {
                    seg.wing.rotation = p.wingRotation * (i % 2 === 0 ? 1 : -1);
                }

                seg.setDepth(100 - i);
            });
        } else {
            p.nameText.setVisible(false);
            p.segments.forEach(s => s.setVisible(false));
        }

        if (pData.Energy > p.lastEnergy) {
            const head = p.segments[0];
            scene.tweens.add({
                targets: head,
                scale: 1.2,
                duration: 100,
                yoyo: true
            });
            const emitter = scene.add.particles(0, 0, 'parrot_head', {
                x: pData.X,
                y: pData.Y,
                speed: { min: 50, max: 150 },
                scale: { start: 0.1, end: 0 },
                lifespan: 400,
                tint: p.color.base,
                maxParticles: 5
            });
            scene.time.delayedCall(400, () => emitter.destroy());
        }
        p.lastEnergy = pData.Energy;

        p.nameText.x = pData.X;
        p.nameText.y = pData.Y - 60 * size;
        p.nameText.setDepth(200);

        if (pData.Id === playerId) {
            cam.startFollow(p.segments[0], true, 0.1, 0.1);
            const zoom = Math.max(0.3, 0.8 / size);
            cam.setZoom(Phaser.Math.Linear(cam.zoom, zoom, 0.1));
        }
    });

    if (scene.miniMapSnakes && scene.miniMapPlayer) {
        scene.miniMapSnakes.clear();
        scene.miniMapPlayer.clear();
        const miniMapSize = 200;
        const scale = miniMapSize / (mapRadius * 2);

        data.Parrots.forEach(pData => {
            if (!pData.Segments || pData.Segments.length < 2) return;

            const isLocal = pData.Id === playerId;
            const color = isLocal ? 0xffffff : (players[pData.Id]?.color?.base || 0xff0000);
            
            scene.miniMapSnakes.lineStyle(2, color, isLocal ? 1 : 0.7);
            scene.miniMapSnakes.beginPath();
            
            pData.Segments.forEach((seg, idx) => {
                const sx = seg.X * scale;
                const sy = seg.Y * scale;
                if (idx === 0) scene.miniMapSnakes.moveTo(sx, sy);
                else scene.miniMapSnakes.lineTo(sx, sy);
            });
            
            scene.miniMapSnakes.strokePath();

            if (isLocal) {
                scene.miniMapPlayer.fillStyle(0xffffff, 1);
                scene.miniMapPlayer.fillCircle(pData.X * scale, pData.Y * scale, 3);
            }
        });
    }

    const currentFeatherIds = (data && data.Feathers) ? data.Feathers.map(f => f.Id) : [];
    Object.keys(feathers).forEach(id => {
        if (!currentFeatherIds.includes(id)) {
            if (feathers[id] && typeof feathers[id].destroy === 'function') {
                feathers[id].destroy();
            }
            delete feathers[id];
        }
    });

    if (data && data.Feathers) {
        data.Feathers.forEach(fData => {
            if (!fData || !fData.Id) return;
            
            if (!feathers[fData.Id]) {
                let color = 0xf1c40f;
                let radius = 6;
                if (fData.Type === 0) {
                    const foodColors = [0x00ffa3, 0x00d1ff, 0xfff500, 0xff005c, 0xff9100, 0x00ff22];
                    color = foodColors[Math.floor(Math.random() * foodColors.length)];
                } else if (fData.Type === 1) {
                    color = 0xffffff;
                    radius = 8;
                } else if (fData.Type === 2) {
                    color = 0xff4d6d;
                    radius = 5;
                }
                
                const feather = scene.add.circle(fData.X, fData.Y, radius * fData.Value, color);
                feather.setStrokeStyle(1, 0xffffff, 0.3);
                feathers[fData.Id] = feather;

                scene.tweens.add({
                    targets: feather,
                    scale: 1.2,
                    duration: 800 + Math.random() * 400,
                    yoyo: true,
                    repeat: -1,
                    ease: 'Sine.easeInOut'
                });
            }
        });
    }
}

function updateLeaderboard(entries) {
    const list = document.getElementById('leaderboard');
    list.innerHTML = entries.map((e, i) => `<div>${i+1}. ${e.Name}: ${Math.floor(e.Score)}</div>`).join('');
}

function update() {
    if (!socket || socket.readyState !== WebSocket.OPEN || !playerId || !cam) return;

    try {
        const pointer = this.input.activePointer;
        if (!pointer) return;
        
        const worldPoint = cam.getWorldPoint(pointer.x, pointer.y);
        if (!worldPoint) return;

        const isBoosting = (cursors && cursors.space && cursors.space.isDown) || pointer.isDown;

        socket.send(JSON.stringify({
            Type: 'input',
            TargetX: worldPoint.x,
            TargetY: worldPoint.y,
            IsBoosting: isBoosting
        }));
    } catch (err) {
    }
}

window.addEventListener('resize', () => {
    if (game && game.scale) {
        game.scale.resize(window.innerWidth, window.innerHeight);
    }
    
    const scene = (game && game.scene && game.scene.scenes) ? game.scene.scenes[0] : null;
    if (scene && scene.miniMapContainer) {
        const miniMapSize = 200;
        const miniMapMargin = 20;
        scene.miniMapContainer.setPosition(miniMapMargin, scene.scale.height - miniMapSize - miniMapMargin);
    }
})};
